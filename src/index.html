<!--
 * @Descripttion: 
 * @version: 
 * @Author: XYK
 * @Date: 2021-07-21 09:40:40
 * @LastEditors: XYK
 * @LastEditTime: 2021-09-09 14:49:33
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    <script src="./js/dat.js"></script>
</head>

<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        const models = [] //所有加载的模型
        let pickedMesh = null // 当前选中的元素
        const canvas = document.querySelector('#renderCanvas')
        const engine = new BABYLON.Engine(canvas, true, { stencil: true })
        const { scene, camera } = createScene()
        // 光照
        const light = new BABYLON.HemisphericLight(new BABYLON.Vector3(0, 1, 0))
        // 加载模型
        loadModel()
        initGUI()
        // 增加高亮渲染层.
        const hl = new BABYLON.HighlightLayer("hl1", scene);
        // 引擎渲染画面
        engine.runRenderLoop(function () {
            scene.render();
        });
        // 监听浏览器resize事件
        window.addEventListener("resize", function () {
            engine.resize();
        });
        // 创建视图
        function createScene() {
            // 主视图
            const scene = new BABYLON.Scene(engine)
            // 相机
            var camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 2, Math.PI / 2, 2000, new BABYLON.Vector3(0, 400, 0));
            // This positions the camera
            // camera.setPosition(new BABYLON.Vector3(0, 3400, 0));
            // This attaches the camera to the canvas
            camera.attachControl(canvas, false);
            //自旋转
            camera.useAutoRotationBehavior = true
            // 自转速度

            // 鼠标事件
            scene.onPointerObservable.add((pointerInfo) => {
                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        // console.log(pointerInfo)
                        break
                }
            });
            return { scene, camera }
        }
        // 加载模型
        function loadModel() {
            BABYLON.SceneLoader.ImportMeshAsync("", "/models/sazabi_ver.ka/", "scene.gltf").then((result) => {
                models.push(result)
                const meshes = result.meshes
                meshes.filter(mesh => mesh.material).forEach(mesh => {

                    mesh.isPickable = true
                    setMeshActions(mesh)
                })
            });
            // BABYLON.SceneLoader.ImportMeshAsync("", "/resources/models/zelda/", "scene.gltf").then((result) => {
            //     const { meshes } = result
            //     models.push(result)
            //     meshes.forEach(mesh => {
            //         const { material } = mesh
            //         material
            //         mesh.isPickable = true
            //         setMeshActions(mesh)
            //     })
            // });
            // BABYLON.SceneLoader.ImportMeshAsync("", "/resources/models/adamHead/", 'adamHead.gltf').then((result) => {
            //     const { meshes } = result
            //     camera.position = meshes[0].position

            //     meshes.forEach(mesh => {

            //         mesh.isPickable = true
            //         setMeshActions(mesh)
            //     })
            // });

        }
        // 模型交互事件
        function setMeshActions(mesh) {
            mesh.actionManager = new BABYLON.ActionManager(scene);
            mesh.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    {
                        trigger: BABYLON.ActionManager.OnPointerOverTrigger,
                    },
                    function (e) {
                        const dpic = scene.pick(scene.pointerX, scene.pointerY);
                        hl.removeAllMeshes()
                        hl.addMesh(dpic.pickedMesh, BABYLON.Color3.Green())
                    }
                )
            );
            mesh.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    {
                        trigger: BABYLON.ActionManager.OnPickTrigger,
                    },
                    function (e) {
                        const dpic = scene.pick(scene.pointerX, scene.pointerY);
                        console.log(dpic.pickedMesh)
                        pickedMesh = dpic.pickedMesh
                        picker.text = pickedMesh.name
                        picker.value = pickedMesh.material.albedoColor;
                        hl.removeAllMeshes()
                    }
                )
            );
        }
        // 初始化GUI
        function initGUI() {
            // ColorPicker
            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            var panel = new BABYLON.GUI.StackPanel();
            panel.width = "200px";
            panel.isVertical = true;
            panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            advancedTexture.addControl(panel);

            var textBlock = new BABYLON.GUI.TextBlock();
            textBlock.text = "Diffuse color:";
            textBlock.height = "30px";
            panel.addControl(textBlock);

            window.picker = new BABYLON.GUI.ColorPicker();
            picker.height = "150px";
            picker.width = "150px";
            picker.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            picker.onValueChangedObservable.add(function (value) { // value is a color3
                // console.log(pickedMesh.material)
                if (!pickedMesh) return
                pickedMesh.material.albedoColor
                    .copyFrom(value);
            });
            panel.addControl(picker);

            // selectBox
            var selectBox = new BABYLON.GUI.SelectionPanel("sp");
            selectBox.color = 'white'
            selectBox.width = 0.25;
            selectBox.height = 0.48;
            selectBox.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            selectBox.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            advancedTexture.addControl(selectBox);

            var transformGroup = new BABYLON.GUI.CheckboxGroup("颜色模式");
            transformGroup.addCheckbox("emmisive", changeColorMode);
            selectBox.addGroup(transformGroup)

            var colorGroup = new BABYLON.GUI.RadioGroup("材质");
            colorGroup.addRadio("Blue", changeMaterial, true);
            colorGroup.addRadio("Red", changeMaterial);
            selectBox.addGroup(colorGroup)


        }
        // 创建材质
        function createMaterial() {
            var myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
            myMaterial.diffuseColor = new BABYLON.Color3(1, 0, 1);
            myMaterial.albedoColor = new BABYLON.Color3(0.5, 0.6, 0.87);
            myMaterial.ambientColor = new BABYLON.Color3(0.23, 0.98, 0.53);
            return myMaterial
        }
        function changeColorMode() {

        }
        // 切换材质
        function changeMaterial() {
            if (!models.length)
                return
            var pbr = new BABYLON.PBRMetallicRoughnessMaterial("pbr", scene);
            pbr.baseColor = pickedMesh.material.albedoColor;
            pbr.albedoColor = pickedMesh.material.albedoColor
            pbr.metallic = 1.0;
            pbr.roughness = 0.0;
            pickedMesh.material = pbr;
        }
    </script>
</body>

</html>